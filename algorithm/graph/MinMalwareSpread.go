package graph

import (
	"math"
)

// https://leetcode-cn.com/problems/minimize-malware-spread/
// 题目：924. 尽量减少恶意软件的传播
// 难度：hard
// 解题思路：
// 1. 给连通分量上色
// 2. 计算每个连通分量的大小
// 3. 找到initial中唯一的颜色
// 4. 选择答案
// 5. 如果没有颜色唯一的节点，直接返回min(initial)
func minMalwareSpread(graph [][]int, initial []int) int {
	// 1. 给连通分量上色
	colors := make([]int, len(graph))
	for i, _ := range colors {
		colors[i] = -1
	}

	c := 0
	for node := 0; node < len(graph); node++ {
		if colors[node] == -1 {
			dfs(graph, colors, node, c)
			c += 1
		}
	}

	// 2. 计算每个连通分量（颜色）的大小
	size := make([]int, c)
	for _, color := range colors {
		size[color]++
	}

	// 3. 找initial中唯一的颜色
	colorCount := make([]int, c)
	for _, node := range initial {
		colorCount[colors[node]]++
	}

	// 4.选择答案
	ans := math.MaxInt32
	for _, node := range initial {
		color := colors[node]
		if colorCount[color] == 1 {
			if ans == math.MaxInt32 {
				ans = node
			} else if size[color] > size[colors[ans]] {
				ans = node
			} else if size[color] == size[colors[ans]] && node < ans {
				ans = node
			}
		}
	}
	if ans == math.MaxInt32 {
		for _, node := range initial {
			ans = min(ans, node)
		}
	}
	return ans
}

func min(x, y int) int {
	if x < y {
		return x
	}
	return y
}

func dfs(graph [][]int, colors []int, node int, color int) {
	colors[node] = color
	for nei := 0; nei < len(graph); nei++ {
		if graph[node][nei] == 1 && colors[nei] == -1 {
			dfs(graph, colors, nei, color)
		}
	}
}
